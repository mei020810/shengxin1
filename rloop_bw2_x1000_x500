vim bw2_x1000_rloop.sh
#!/bin/bash
# 设置最大并发任务数
MAX_JOBS=2
current_jobs=0
INDEX_BASE="/data/mshe/rloopData/index/Gmax_508_v4.0.bw2"
mkdir -p /data/mshe/rloopData/sam_x1000

echo "=== 开始Bowtie2比对分析 ==="
echo "开始时间: $(date)"
echo "索引: $INDEX_BASE"
echo "最大并发任务: $MAX_JOBS"

# 首先检查总样本数
total_samples=$(ls trimmed_results/*_R1_val_1.fq.gz | wc -l)
echo "检测到总样本数: $total_samples"
echo ""
processed_count=0
skipped_count=0

for r1_file1 in trimmed_results/*_R1_val_1.fq.gz; do
    # 提取样本名（去掉路径和_R1_val_1.fq.gz）
    sample=$(basename "$r1_file1" _R1_val_1.fq.gz)
    
    # 检查对应的R2文件是否存在
    r2_file1="trimmed_results/${sample}_R2_val_2.fq.gz"
    if [ ! -f "$r2_file1" ]; then
        echo "警告: 找不到对应的R2文件 $r2_file1，跳过"
        skipped_count=$((skipped_count + 1))
        continue
    fi
    # 定义输出文件
    sam_file="/data/mshe/rloopData/sam_x1000/${sample}_x1000.bw2.sam"
    log_file="/data/mshe/rloopData/sam_x1000/${sample}_x1000_bw2.log"

    # 检查是否已经成功处理过（避免重复运行）
    if [ -f "$sam_file" ] && [ -f "$log_file" ]; then
        # 检查日志中是否有成功完成的标记
        if grep -q "overall alignment rate" "$log_file" 2>/dev/null; then
            echo "跳过: $sample 已处理完成"
            skipped_count=$((skipped_count + 1))
            continue
        else
            echo "重新运行: $sample 上次运行可能不完整"
            # 删除不完整的文件
            rm -f "$sam_file" "$log_file"
        fi
    fi

    while [ $(jobs -r | wc -l) -ge $MAX_JOBS ]; do
        echo "等待空闲资源... 当前运行任务: $(jobs -r | wc -l)"
        sleep 60
    done
    echo "启动: $sample - $(date)"
    processed_count=$((processed_count + 1))
nohup bowtie2 --end-to-end --no-discordant --no-mixed \
        -p 8 \
        -X 1000 \
        -x "$INDEX_BASE" \
        -1 "$r1_file1" \
        -2 "$r2_file1" \
        -S "$sam_file" > "$log_file" 2>&1 &

    echo "进度: 已提交 $processed_count/$total_samples 个任务"
    sleep 10
done 
echo ""
echo "所有任务提交完成!"
echo "处理: $processed_count, 跳过: $skipped_count, 总计: $total_samples"
echo "等待最终完成..."
wait

echo "=== 最终统计结果 ==="

for log_file1 in /data/mshe/rloopData/sam_x1000/*_x1000_bw2.log; do
    if [ -f "$log_file1" ]; then
        sample=$(basename "$log_file1" _bw2.log)
        alignment_rate=$(grep "overall alignment rate" "$log_file1" | awk '{print $1}' | tr -d '%')
        total_reads=$(grep "reads; of these:" "$log_file1" | awk '{print $1}')
        
        if [ -n "$alignment_rate" ] && [ -n "$total_reads" ]; then
            echo "$sample | 总序列: $total_reads | 比对率: ${alignment_rate}%"
        else
            echo "$sample | 统计信息提取失败"
        fi
    fi
done | sort -t'|' -k5 -nr

echo "全部任务完成！时间: $(date)"

chmod u+x bw2_x1000_rloop.sh
nohup ./bw2_x1000_rloop.sh > "bw2_x1000_rloop.log" 2>&1 &    # tail -f bw2_x1000_rloop.log


vim bw2_x500_rloop.sh
#!/bin/bash
# 设置最大并发任务数
MAX_JOBS=2
current_jobs=0
INDEX_BASE="/data/mshe/rloopData/index/Gmax_508_v4.0.bw2"
mkdir -p /data/mshe/rloopData/sam_x500

echo "=== 开始Bowtie2比对分析 ==="
echo "开始时间: $(date)"
echo "索引: $INDEX_BASE"
echo "最大并发任务: $MAX_JOBS"

all_samples=("HC22-1-IP" "HC22-2-IP" "HH43-2-input" "HH43-2-IP" "Wm82-2-IP" "ZH13-2-input" "ZH13-2-IP")
for sample in "${all_samples[@]}"; do
    r1_file="/data/mshe/rloopData/trimmed_results/${sample}_R1_val_1.fq.gz"
    r2_file="/data/mshe/rloopData/trimmed_results/${sample}_R2_val_2.fq.gz"
    while [ $(jobs -r | wc -l) -ge $MAX_JOBS ]; do
        echo "等待空闲资源... 当前运行任务: $(jobs -r | wc -l)"
        sleep 60
    done
    echo "启动: $sample - $(date)"

nohup bowtie2 --end-to-end --no-discordant --no-mixed \
        -p 8 \
        -X 500 \
        -x "$INDEX_BASE" \
        -1 "$r1_file" \
        -2 "$r2_file" \
        -S "/data/mshe/rloopData/sam_x500/${sample}_x500.bw2.sam" > "/data/mshe/rloopData/sam_x500/${sample}_x500_bw2.log" 2>&1 &

    current_jobs=$((current_jobs + 1))
    echo "进度: $current_jobs 个任务已提交"
    
    sleep 5
done 
echo "所有任务提交完成，等待最终完成..."
wait

echo "=== 最终统计结果 ==="

for log_file in /data/mshe/rloopData/sam_x500/*_x500_bw2.log; do
    if [ -f "$log_file" ]; then
        sample=$(basename "$log_file" _x500_bw2.log)
        alignment_rate=$(grep "overall alignment rate" "$log_file" | awk '{print $1}' | tr -d '%')
        total_reads=$(grep "reads; of these:" "$log_file" | awk '{print $1}')
        
        if [ -n "$alignment_rate" ] && [ -n "$total_reads" ]; then
            echo "$sample | 总序列: $total_reads | 比对率: ${alignment_rate}%"
        else
            echo "$sample | 统计信息提取失败"
        fi
    fi
done | sort -t'|' -k5 -nr

echo "全部任务完成！时间: $(date)"
chmod u+x bw2_x500_rloop.sh
nohup ./bw2_x500_rloop.sh > "bw2_x500_rloop.log" 2>&1 & #tail -f bw2_x500_rloop.log

#查看1000的插入片段分布
vim quick_insert_size_summary.sh
#!/bin/bash
echo "样本 | <100bp | 100-200bp | 200-300bp | 300-500bp | >500bp | >800bp"
echo "--- | --- | --- | --- | --- | --- | ---"

for sam_file in /data/mshe/rloopData/sam_x1000/*.bw2.sam; do
    sample=$(basename "$sam_file" .bw2.sam)
    
    samtools view -f 2 "$sam_file" 2>/dev/null | \
    awk 'function abs(x){return ((x < 0.0) ? -x : x)} 
         {
           size = abs($9);
           if(size > 0) {
             if(size < 100) a++;
             else if(size <= 200) b++;
             else if(size <= 300) c++;
             else if(size <= 500) d++;
             else e++;
             
             if(size > 800) f++;
             total++;
           }
         }
         END {
           if(total > 0) {
             printf "%s | %d (%.1f%%) | %d (%.1f%%) | %d (%.1f%%) | %d (%.1f%%) | %d (%.1f%%) | %d (%.1f%%)\n",
                    "'"$sample"'", 
                    a, a/total*100, b, b/total*100, c, c/total*100,
                    d, d/total*100, e, e/total*100, f, f/total*100;
           }
         }'
done
chmod +x quick_insert_size_summary.sh
./quick_insert_size_summary.sh > insert_size_summary.txt


